{
    "defunct": {
        "content": "#### \"DeFunct\"\n\nThis section of the guidebook is strictly dedicated toward CodeBytes' own syntactic language. \"DeFunct\" comes from the emphasis on the capabilities of the language, especially toward functions. More on that later.\n\nIt is not a real programming language and it does not have a compiler, but it will frequently show up in Theoretical Assessment events and occasionally in others. As a result, it is imperative that you have an understanding of how DeFunct works for your own advantage.\n\n#### The Banter\n\nThe general syntax for DeFunct can be confusing at first glance. However, some portions are similar to other languages. We'll be talking about changes frequently.\n\nFirst, to understand the basics, you must know DeFunct's defining feature:\u00a0**Dynamic Function Updates**.  \nWhat does this mean? I'm glad you asked!\n\nThat means that all code written for a function is\u00a0**not**\u00a0permanently etched into a program during compilation. Code can be written, deleted, moved, or reset during runtime, alongside protected instances.\n\nWhat does that mean in the long run? More flexibility in how to run your program and how functions behave... and more vulnerable states for your program.\n\nBelow is a snippet of valid code for DeFunct.\n\n```rust\ndeclare : string : finisher = \"CodeBytes\"\n// Declares an explicit variable of type string with identifier \"finisher\".\n\ndeclare message = \"Hello from\"\n// Declares an dynamically typed variable with identifier \"message\" that complexes into a string datatype.\n\ndefine funct() = {\n\u2003return (message + \" \" + finisher)\n}\n// Defines a function with a run command of \"return\" that concatenates the strings together.\n\noutput funct()\n// The run command of \"output\" that prints out \"Hello from CodeBytes\" into the output.\n```\n\nKeep close attention to the wording of the comments. The first thing to note is the leniency regarding\u00a0**datatypes.**\n\nVariables must be declared by the \"declare\" keyword - this applies to both primitive and class-defined datatypes. The declaration statement may be explicit or dynamically typed, as demonstrated by the first two calls of the snippet. The first call involves an explicit declaration, meaning the type is defined. This means that the variable \"finisher\" must be a string. However, the second call is dynamically typed, and assumes the value of whatever is passed through the declaration statement. We call this a complexation, as the dynamically typed type is assigned a type. In this case, \"name\" complexes from dynamically typed to a string.\n\nWhat about functions? In this example, they are not complicated yet. A function is defined by the \"define\" keyword. It uses curly braces as a means to contain its code. For this function, it returns another string. Did you notice that the function had no specified return type?\n\nThat's right! It can be dynamically typed as well. For strictly defined values, you can define a function as such:\n\n```rust\ndefine : string : funct() = {...}\n```\n\nWhich will restrict the return statement much, much more!  \nAlso, to note, most functions and statements, etc. can be separated by curly braces and parentheses.\n\nFinally, the \"output\" statement. It runs just as expected. But, an important note was brought up in the comment: run commands.\n\nAll statements in the program must have a run command activating it. The most basic command is \"run\", which can precede most calls. Other ones such as \"output\", \"input\", \"return\", and others count as run commands. In general, a command that precedes some function or variable is usually going to be a function call.\n\nThis, of course, is not always the case. Lets see the below example:\n\n```rust\ndeclare : integer : points = 0\n// Explicit declaration of an integer.\n\nrun points = 5\n// Complete update of \"points\" from 0 to 5.\n\npoints -= 6\n// Implicit subtractive run function on \"points\", taking it from 5 to -1.\n// This is the same as 'run points -= 6'\n\npoints++\n// Implicit additive run function on \"points\", taking it from -1 to 0.\n// This is the same as 'run points++'\n```\n\nInteresting, huh? In general, it is good practice to follow the run command convention, as that is how the entirety of the language functions at a basic level, but it is generally implied through certain function calls that a variable is being updated. For most primitive datatypes, there will be implicit functions to accompany you. However, for external classes or more complex datatypes, a run command may become required.\n\nAlright, let's get to some more basics, and then the good stuff. First, we'll talk about the primitive datatypes. For this section, it is expected that you only have to read the code snippets. After the datatypes, we'll throw in some common functions, and a bit more magic before the dynamic parts. Also... YOUR VARIABLES CANNOT BE NAMED A PRIMITIVE DATATYPE!\n\n```rust\ndeclare : short : ex1 = 0S\n// short datatype, the max and min values this datatype can hold are found by \"short.MIN\" and \"short.MAX\" Respectively, the values are:\n// -32786, 32767.\n\ndeclare : integer : ex2 = 0\n// integer datatype, the max and min values this datatype can hold are found by \"integer.MAX\" and \"integer.MIN\" Respectively, the values are:\n// -2147483648, 2147483647.\n\ndeclare : long : ex3 = 0L\n// long datatype, the max and min values this datatype can hold are found by \"long.MAX\" and \"long.MIN\" Respectively, the values are:\n// -9223372036854775808, 9223372036854775807.\n// Note: The long datatype functions similarly to the long long datatype in C++.\n\ndeclare : decimal : ex4 = 0.0\n// decimal datatype, the max and\n\ndeclare : integer : ex2 = 0\n// integer datatype, the max and min values this datatype can hold are found by \"integer.MAX\" and \"integer.MIN\" Respectively, the values are:\n// -2147483648, 2147483647.\n\ndeclare : long : ex3 = 0L\n// long datatype, the max and min values this datatype can hold are found by \"long.MAX\" and \"long.MIN\" Respectively, the values are:\n// -9223372036854775808, 9223372036854775807.\n// Note: The long datatype functions similarly to the long long datatype in C++.   min values this datatype can hold are found by \"decimal.MAX\" and \"decimal.MIN\" Respectively, the values are:\n// 2.2250738585072014e-308, 1.7976931348623158e+308, regardless of sign.\n\n\ndeclare : string : exs = \"hi there\"\n// string datatype. Functions very similar to other string types in other languages. In DeFunct, a character is a single-slot string.\n// Individual characters can be accessed in strings by way of indices. For example, \"exs[0]\" returns \"h\".\n// A range of values in a string can also be accessed by way of indices, using ranges. \"exs[0,1]\" returns \"hi\". Note that it is inclusive.\n// Other noteable functions: \"string.uppercase(#string)\", \"#string.indexOf(#string)\", \"#string.lastIndexOf(#string)\", \"string.len(#string)\", \"string.lowercase(#string)\", \"string.replace(#string, #string)\" (where arg1 is the old string and arg2 is the new string).\n\ndeclare : vector : exv1 = <0,1>\n// vector datatype. Can be declared explicitly like done here, or can be done implicitly as shown here:\ndeclare exv2<3,2,5>\n\ndeclare : array : exa1 = [6]{1,2,3,4,5,6}\n// fixed array datatype. This is the strictly explicit declaration, where the size is fixed at 6 and values given.\ndeclare : array : exa2 = {1,2,3,4,5,6}\n// loose array datatype. This is the lenient explicit declaration, where the size is not fixed at 6, but the values were given to start.\ndeclare : array : exa3[4]{1,2,3,4}\n// fixed array datatype. This is the strictly implicit declaration, where the size is fixed at 4 and values given.\ndeclare : array : exa4{1,2,3,4}\n// loose array datatype. This is the strictly implicit declaration, where the size is not fixed at 4, but the values were given to start.\n// For all of these, you may also choose not to provide values, but the array will need to be defined later.\n\n// Also, arrays are similar to strings by way of indices. An array can be given an explicit type, like:\ndeclare : array[integer] : exa4{1,2,3,4}\n// If unspecified, though, the array will be dynamically typed permanently and will not complex without a special command.\n\ndeclare : boolean : exb = TRUE;\n// boolean datatype. Assumes the TRUE value, which is equivalent to 1.\n// Also supports the FALSE value, which is equivalent to 0... And NaN, which is the equivalent to null in other languages.\n```\n\nAs promised, the common functions, too! These all return values, so make sure to store them!\n\n```rust\nrun pow(#number, #integer)\n// Classic power function: A^B\n\nrun root(#number, #integer)\n// Optimized root function, better than using power for roots: A^(1/B)\n\nrun abs(#number)\n// |A|\n\nrun max(#number,#number)\n// Determines which input is the maximum.\n\nrun min(#number,#number)\n// Determines which input is the minimum.\n\nrun random(#number,#number, #/boolean)\n// Returns a value from A to B, inclusive (listed in order). If the last digit must be exclusive, you may pass TRUE into the optional third argument.\n\nrun round(#number, #integer)\n// Rounds a number up to an integer number of decimal places. Automatically rounds up.\n  ted.  on to arrays results in a loose array.\n\ncomplex argument : #datatype\n// Complexes an extended primitive datatype such as a vector or an array, or functions with datatypes.\n```\n\nWhoo! That a was a lot, wasn't it?  \nNever fear, there's only a little more left to learn before you understand the basics of the language.\n\nLet's talk about if-else statements and loops.\n\nIterative Loops (for loops) are extended primitive datatypes that\u00a0**cannot**\u00a0be complexed. For this reason, we call it a simpleton dataclass.\n\nIterative Loops are very interesting as they can remain undefined just like functions and variables until expanded. Once again, we will discuss expansions later, but for now, understand that they can be treated just like a variable.\n\nSee this:\n\n```rust\ndeclare : iterativeloop : myloop = [i = 0, i < 1000, i++]{...}\n// This segment declares an iterativeloop that is called myloop. The brackets denote the bounds of the loop, where the loop will begin at 0, increment by 1 each iteration, and end once i = 1000.\n// Inside the curly braces is where you put your code. This is the strictly explicit construction.\n\n// Here are some more constructions.\ndeclare : iterativeloop : myloop = [i = 0, i < 1000, i++]{...}\ndeclare myloop2 = [i = 0, i < 1000, i++]{...}\ndeclare myloop3[i = 0, i < 1000, i++]{...}\ndeclare myloop4[i = 0, i < 1000, i++]\n// Note that this loop has no code associated to it. More on that later.\ndefine funct() = myloop5[i = 0, i < 1000, i++]\n// Note that the \"declare\" keyword is not required if a function only consists of a loop. More on that later.\n```\n\nLots of ways to make iterative loops. Indefinite (while) loops function similarly...\n\n```rust\ndeclare : integer : i = 0\ndeclare : indefiniteloop : myloop = [i < 10]{...}\n// This segment declares an indefinite loop that is called myloop. The brackets denote the condition of the loop. It has the same construction syntax as does iterativeloops. However, note that you will have to define i beforehand.\n// Inside the curly braces is where you put your code. This is the strictly explicit construction.\n```\n\nNo surprises! Loops are the same, just formed as a simpleton dataclass.\n\nIf-Else statements will be syntactically different from most other languages, though.  \nInstead of the usual process where you write an if statement with the condition, then the code, then the else statement, DeFunct uses branches. How do branches work? Well... It is a little complicated.\n\nLet's look at this code:\n\n```rust\ndefine f(x) = {f(x-2) + 1 if (x > 0)}\nexpand f(x) = {f(x+1) - 1 if (x < 0)}\nexpand f(x) = {return 2 if (x = 0)}\n// This defines a function with a single line, which is a branch. Essentially, this branch acts as a single if statement. However, we later expand our function to include a new branch. We can do this however many times we want, so long as the original branch is still in direct line of the expansion.\n\n// This can get confusing really quickly, so I will display what the function looks like from a critical level:\n// f(x) = {A, B, C}\n// Internally, the function is split into three sections. A is our initial branch, what we defined.\n// Each expansion is then added after eachother in the function definition. So now, when f(x) is run, all three lines run in order.\n\n// This is where the dynamic functions aspect comes in. Expansions can be done anytime in a program. They can also be moved around by a command, \"align\", which works like:\nalign f(x) = [2,3]\n// Which makes our int\nshrink h(x) = [3]\n// The \"shrink\" keyword allows for the removal of branches internally from a function.\n// This allows you to remove code without completely clearing the definition. Only works for functions or simpleton dataclasses.\n\ndelete h(x)\n// This removes h(x) from memory. While functions and variables that do not get used after a while are naturally handled as trash, it is nice.  ernal function swap the 2nd expansion with the third, so,\n// f(x) = {A, C, B}\n// This can be used anytime.\n// Now that expansions are out of the way, if statements work by expanded code best, but it can also be defined in the same definition. See g(x) below:\n\ndefine g(x) = {\n\u2003run g(x-2) + 1 if (x > 0)\n\u2003run g(x+1) - 1 if (x < 0)\n\u2003return 2 if (x = 0)\n}\n\n// Here, the run commands are required as the function is now in an extended fashion, so each line now has to be differentiated from the other. The if branches themselves do not have an else keyword at all, and instead only function by \"if\" branches. Again, the accompanying branches function exactly as an else statement as long as it is connected to the original if statement.\n```\n\nThat's all folks! At least, that's all for the if-statements and loops.\n\nThe last thing we need to cover are a few more properties of expansions. See the code snippet below.\n\n```rust\n// Remember how loops can be undefined? Well, they can be expanded!\ndeclare myloop[i = 0, i < 1000, i++]\n\nexpand myloop = {...}\n// Boom! Now the loop has a definition inside the curly braces, assuming there is code inside. This definition can be expanded and changed over time as the program runs! Loops have another really interesting property regarding scopes, which we'll discuss now!\n\ndefine f(x) = {myloop2[i = 0, i < x, i++]}\nexpand myloop2 = {...}\n// Here, you may notice that the bounds for myloop2 involve the argument for the function f(x). As a consequence, myloop2 cannot be run outside of a function. When it is expanded, it can take on the values of \"x\" and \"i\", as indicated by the bounds. But what happens in a situation like this?:\n\ndefine g(x) = {myloop2}\n// Conflicting variables! But never fear, this is where scope comes into play. If a function, g(x) is defined to have the same named argument as does the variable in myloop2, then g(x) will allow myloop2 to run, but with x relating to g(x). If the function instead had a name of g(n), it would no longer be valid and myloop2 would throw an UNKNOWNVAREXCEPTION.\n\n// A few more topics!\n\nclear myloop2\n// The \"clear\" keyword removes all functional definitions from myloop2, except the bounds.\n// This command can be run on fixed arrays and functions, too.\n\ndefine h(x) = {h(x-2) + 1 if (x > 0)}\nexpand h(x) = {h(x+1) - 1 if (x < 0)}\nexpand h(x) = {return 2 if (x = 0)}\nshrink h(x) = [3]\n// The \"shrink\" keyword allows for the removal of branches internally from a function.\n// This allows you to remove code without completely clearing the definition. Only works for functions or simpleton dataclasses.\n\ndelete h(x)\n// This removes h(x) from memory. While functions and variables that do not get used after a while are naturally handled as trash, it is nice.\n```\n\nCongratulations! You made it through the majority of the language. Be rest assured that common functions and other information will be provided during the Theoretical Assessment via a packet, but do not rely on this to guarantee your success. Get associated with the language!\n\nThis page will likely be updated over time.  \n**Goodluck!**\n"
    },
    "events": {
        "content": "#### Foreword\n\nThis page is meant to be a more user-friendly guidebook to understanding the competitions.\n\nThe information listed here is not meant to be viewed as a replacement for the original rules put in place, unless otherwise specified.\n\n---\n\n#### Team Guidelines\n\nThis section is intended to remind and clarify information upon teams.\n\n- Teams can only have up to 4 members. However, participants are free to work individually if they'd like.\n  - That is, teams can be less than 4 members, and can allow for the members to jump between\u00a0**Simultaneous Events**.\n    - **Simultaneous Events**\u00a0are when there is more than one event ongoing at the same time. It is generally permitted for participants to jump between these events while that block is ongoing.\n  - No compensatory points will be given to teams that have less than four members. However, individuals may be given bragging rights if they happen to be the best-scoring out of all participants.\n- Only the points of the top 3 teams from a school will count towards their school's total points.\n  - This is to combat school size from dominating the leaderboards. If a school has less than two teams participating, a third \"placeholder\" team based on some criterion decided during the event will be incorporated into their scoring.\n    - This criterion may involve the median, mean, or mode scores of all schools. This will be determined by the committee during the event.\n  - For a team's points to be considered toward a school's score, the team must be made up of only students from that school.\n    - Teams made up of students from different schools may still be eligible for prizes, but their points will not be counted for any school in particular, and are not placed on the leaderboard.\n- A team's total points includes the sum of all the points earned from the events they participated in.\n  - Once a block is over, all points are finalized for that block. Late submissions for each event will not be accepted, unless the committee deems it necessary.\n  - Some events may have special requirements regarding their points. Be sure to review their information before the competition.\n- Teams must have an account to participate in the contest.\n  - Submissions may be permitted without an account (for the sake of practice and testing), but points and leaderboard placements cannot be given without registration.\n- Cross - Team Communication whether it is to their own or some other school is forbidden during the events.\n  - This only applies to the event matter at hand. Conversation is permitted, but discussion of algorithms or answers are not.\n- In the event of a team dissolving in the middle of a competition, all prior points will be ignored.\n  - That is, any points earned by the team will not be \"split\" into new forming teams. Ongoing team-creation must be done during a break, and with permission from the committee.\n\n---\n\n#### Event Guidelines\n\nThis section is intended to remind and clarify information upon events.\n\n- Events are judged according to their own set of criteria by competition organizers.\n  - Judges will be from multiple schools, and maintain a no-bias policy to keep the tournament fair.\n- Events will vary in total points offered, and will be specified before the competition begins.\n  - More information will be provided in the event descriptions and the contest's page. Be sure to check in frequently.\n- Depending on the event, resubmissions may or may not be allowed.\n  - It is a general policy that in the default Competitive Programming Problems event, resubmissions are allowed and even encouraged.\n  - If an error has been found to be made, a resubmission may be permitted.\n- Events follow a \"simultaneous blocking\" pattern, in which the entire competition will be composed of blocks that have multiple events ongoing.\n  - For example, the tournament may consist of two \"blocks\", that happen one after the other, while inside those blocks are \"simultaneous\" events that are ongoing at the same time. Block A contains events 1 and 2 together, while Block B happens after A, containing events 3 and 4 together.\n- The Competitive Programming Problems event is guaranteed for all iterations of CodeBytes. Other events may sprout and decay in different seasons and schedules. These events will be announced a month beforehand.\n  - It is important to keep track of our announcements page, as certain events may be more obscure than others. If practice is on your mind, this is the way.\n- Information and Guidelines relating to each event will be updated and added to this page as an addendum.\n\n---\n\n#### Competitive Programming Problems Event\n\nThis section details the universal \"Competitive Programming Problems\" event, which will be present in every contest.\n\n- Submitted code has to use standard input and standard output.\n  - That is, it cannot have a buffer or read from a file, etc.\n  - It must also remain under the same class. Multiple separated classes are not accepted.\n- Test Case Status:\n  - AC - Accepted.\n  - WA - Wrong Answer.\n  - CE - Compilation Error.\n  - RE - Runtime Error.\n  - TLE - Time Limit Exceeded.\n  - LD - Loading.\n  - ER - Error.\n- The number of problems will vary depending on the competition and complexity. The default remains 10 problems for a total of 1000 points.\n  - This will only change in special events. These will be clarified beforehand.\n  - Each problem contains 10 test cases, with each test case being worth 10 points for a total of 100 possible points per problem.\n- The submission that earns the most points is the only one counted.\n  - There is no limit or penalty for incorrect submissions.\n  - Submissions that are inefficient will not be docked points.\n- Teams are free to use the internet when solving problems, but are not allowed to use any form of AI.\n  - This is a disqualifying offense. No amount of AI is permitted.\n- Submissions may be reviewed if cheating or other issues are suspected. As a result, be wary of the information you submit.\n\n---\n\n#### Front-End Event\n\nThis section details the \"Front End\" event, which may or may not be present in a competition.\n\n- Also known as the \"web-design\" competition, the part of the competition where you have to improvise from scratch.\n  - And we mean,\u00a0*improvise.*\n- Each event, a prompt/theme will be given. It is your responsibility to interpret and expand upon that theme.\n  - For all intents and purposes, your website should be safe for work. Please do not submit vulgar websites, as we will pass the information along to your school.\n- Judged based on set criteria that will be made clear as part of the competition.\n  - Complexity is the first test, ranging from `0 - 10`.\n  - Functionality is the second test, ranging from `0 - 10`.\n  - Aesthetics is probably the most important, the third test, ranging from `0 - 10`.\n  - Responsiveness, or speed, is the final test, ranging from `0 - 10`.\n- StackBlitz will be how we handle submissions for website development. Be ready to create an account if needed!\n- Summed to a final score of 800 points, gained from the sum of all your points multiplied by 20.\n- As this portion is technically subjective, we have multiple judges reviewing the websites to ensure fairness.\n\n---\n\n#### Theoretical Assessment Event\n\nThis section details the \"Theoretical Assessment\" event, which may or may not be present in a competition.\n\n- Better known as the \"Quiz Event\", ranking one of the lowest in scores, but a quick category to achieve.\n  - Notoriously known as the \"be-all end-all\u201d, as once an assessment is submitted, it can never be returned to. The final standing between two teams may very well be differentiated through this event.\n- Composed of categories that discuss different topics, all available at once for a combined total of 800 points.\n  - \"Bit Trivia\" is worth a total of 100 points. This category dives into the history, complexities, and trivial matters of computing. The number of problems is always set to 10 every competition.\n    - All forms of trivia are fair game here. How well can you do?\n  - \"Brute Force\" is worth a total of 200 points. This category is considered the non-trivia multiple choice section, made up of a variety of topics. May or may not be timed, depending on the event description. The number of problems may differ.\n  - \"Problem Statement\" is worth a total of 400 points. This category is considered the free response section, mostly consistent with computational mathematics and theory. The number of problems may differ.\n- Some problems may be worth more than others and will be labeled accordingly as \"Fast Fate\".\n  - Falls under an \"all-or-nothing\" basis. The problem and accompanying problems must be completely correct to qualify as fast-fate.\n- No partial credit will be given on MCQ-type assessments unless otherwise stated or handled.\n- All quizzes will be done on paper and will occur in a separate room from the designated computer labs.\n  - This means that team-communication will be limited. Plan accordingly.\n- Any usage of the internet or outside sources will result in complete disqualification of your team.\n- Calculators are allowed, but external calculator programs are not.\n  - External calculator programs are programs that do not remain in the calculator when the memory is completely erased.\n- All quizzes must be submitted five minutes prior to the event completion for the submissions to be counted for points. Time warnings will be given out before this requirement.\n  - Be very mindful of this rule, exceptions are not given.\n- All answers are final once submitted and cannot be changed.\n  - \u2026Unless otherwise stated!\n\n---\n\n#### Program Optimization Event\n\nThis part of the guidebook is still under construction! Come back later! :D\n"
    },
    "rules": {
        "content": "#### General\n\nWelcome to CodeBytes, a regional coding competition founded by the 2023 - 2024 computing teams of Neuqua Valley High School and Naperville Central High School.\n\nMade with the vision of creating an intuitive experience that incorporates the many flavors of computing, CodeBytes prides itself in its unique event structure and variability. We include the traditional competitive problems that national tournaments focus upon, as well as numerous subjects that reference the vast field of computer science (such as data science, web development, botting, etc.).\n\nWe are a predominantly Illinois-based competition, but all are welcome to participate in the contests. Only highschool-or-equivalent students are eligible to earn prizes. All events are in-person and will have snacks and accomodations included.\n\n#### Permitted Languages\n\nNew languages may be allowed upon request and consideration. A full list of languages supported by our grading system may be seen below:\n\n- C\n- C++\n- Java\n- Kotlin\n- Javascript\n- C#\n- Python\n- Ruby\n- Go\n- Rust\n\n#### Contest Format\n\nEach competition will be different from the last in terms of the amount and types of events, ensuring that each experience is fresh and exciting for the participants.\n\nInformation on individual events and additional content may be found on each competition's packet.\n\n#### Academic Integrity\n\nAll students that participate in CodeBytes are expected to uphold a policy of academic integrity. Since this competition is a school-representative tournament, there are regulations that must be followed to ensure fairness. A list of rules may be found after this section.\n\nBy registering for CodeBytes, it is understood that each student has read and abides by the guidelines set in place. Any violations will be enforced under a \"zero tolerance\" policy and may result in disqualification. Punishments may range from individual event locks, student disqualification, team disintegration, and school disqualification.\n\n#### Code of Conduct\n\nAs mentioned above, this section will discuss the rules that every participant is expected to follow. All rules are final and may be flexible depending on the circumstances. Attempts to circumvent these rules may qualify for disqualification.\n\n1. Teams may only have a maximum of four members.\n\n   - Only the top three teams per school will be considered in the final score count for the school leaderboard.\n   - Teams are only eligible for leaderboard positions if they are made up of members from one single school. Mismatching students may participate and receive prizes, but will not be considered in the final leaderboard scores.\n   - Dividing and conquering is allowed and encouraged.\n\n2. Cross - Cross-team Communication is forbidden and will be considered a form of cheating.\n\n   - This includes communication between one school's teams, or between two different schools' teams.\n   - Casual conversation is permitted. Discussions on answers are not.\n   - Suspicion of communication may result in time or point deductions or disqualification.\n\n3. The usage of AI or any equivalents is strictly prohibited for all events and purposes. Any evidence of this rule being violated will disqualify the entire team.\n\n   - This may extend to a complete ban from CodeBytes. All work must be yours and yours\u00a0**only**.\n\n4. Internet access varies from event to event. Review each event's rules to understand if your team may use the internet's tools to help you succeed.\n\n5. Horseplay, sabotage, or internal misdirection will not be tolerated.\n\n6. Submission of any code that behaves in a malicious manner will result in a permanent ban from future competitions and will be forwarded to authorities.\n\n   - Offenses include tampering with the grading system, slowing the servers, creating network vulnerabilities, script injection, etc.\n   - All code submissions will be done only by our website and any alternative methods or automated processes are not permitted.\n\n7. Unfair attempts to inflate a score or tamper with grading processes will result in a removal from the tournament.\n\n8. Should a tie arise, discussions across all school representatives will undergo to determine if the schools both will compete in a tie-breaker, or if both schools will take home victory.\n\n9. Rules may differ depending on the event, and may be updated over time. It is expected that all participants review the rules before the competition begins.\n\nIf you find a problem with any of the events, rules, or data, contact an organizer immediately.\n"
    }
}